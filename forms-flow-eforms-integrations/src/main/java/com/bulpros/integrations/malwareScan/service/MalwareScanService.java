package com.bulpros.integrations.malwareScan.service;

import com.bulpros.integrations.malwareScan.configuration.MalwareScanConfiguration;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.apache.camel.Exchange;
import org.apache.camel.Message;
import org.apache.camel.attachment.Attachment;
import org.apache.commons.lang3.StringUtils;
import org.springframework.core.ParameterizedTypeReference;
import org.springframework.http.*;
import org.springframework.stereotype.Service;
import org.springframework.util.LinkedMultiValueMap;
import org.springframework.util.MultiValueMap;
import org.springframework.web.client.RestTemplate;

import java.io.ByteArrayInputStream;
import java.util.Map;
import java.util.Objects;

@Service("MalwareScanService")
@RequiredArgsConstructor
@Slf4j
public class MalwareScanService {

    private static final Integer MAX_BYTE_SIZE = 268_435_456; //256mb in bytes
    private final MalwareScanConfiguration configuration;
    private final RestTemplate restTemplateMalwareScan;

    public Boolean scanFiles(Exchange exchange) throws Exception {

        Message message = exchange.getIn();
        ByteArrayInputStream fileByteStream = message.getBody(ByteArrayInputStream.class);
        String filename = message.getHeader("content-disposition").toString().split("\"")[1];
        HttpHeaders headers = new HttpHeaders();
        headers.setContentType(MediaType.MULTIPART_FORM_DATA);

        byte[] bytes = fileByteStream.readAllBytes();
        log.info(String.format("Passing file of size of %s bytes.", bytes.length));

        if (bytes.length > MAX_BYTE_SIZE) {
            log.debug(String.format("File size of %s bytes, exceeding maximum of %s bytes.", bytes.length, MAX_BYTE_SIZE));
            return false;
        }

        MultiValueMap<String, String> fileMap = new LinkedMultiValueMap<>();
        ContentDisposition contentDisposition = ContentDisposition
                .builder("form-data")
                .name("file")
                .filename(filename)
                .build();
        fileMap.add(HttpHeaders.CONTENT_DISPOSITION, contentDisposition.toString());
        HttpEntity<byte[]> fileEntity = new HttpEntity<>(bytes, fileMap);

        MultiValueMap<String, Object> body = new LinkedMultiValueMap<>();
        body.add("file", fileEntity);

        HttpEntity<MultiValueMap<String, Object>> requestEntity
                = new HttpEntity<>(body, headers);

        ResponseEntity<String> responseFileId = restTemplateMalwareScan
                .postForEntity(configuration.getMalwareScanUrl(), requestEntity, String.class);

        final String fileId = StringUtils.strip(responseFileId.getBody(), "\"\n");
        final String getResponseUrl = String.format("%s/%s", configuration.getMalwareScanUrl(), fileId);

        ResponseEntity<Map<Object, Object>> responseFileStatus = null;
        boolean notFinished = true;
        int counter = 0;
        final int maxCount = configuration.getMalwareScanMaxSeconds();
        final int waitSeconds = configuration.getMalwareScanWaitSeconds();

        while (notFinished && counter < maxCount) {
            responseFileStatus = restTemplateMalwareScan.exchange(getResponseUrl, HttpMethod.GET,
                    null, new ParameterizedTypeReference<Map<Object, Object>>() {
                    });
            if (responseFileStatus.hasBody() && Objects.nonNull(responseFileStatus.getBody()) &&
                    responseFileStatus.getBody().get("status").toString().equalsIgnoreCase("Error")) {

                throw new Exception("File cannot be processed!");
            }
            notFinished = isNotCompleted(responseFileStatus);

            if (notFinished) {
                waitForCompletion(waitSeconds);
                counter++;
            }
        }

        if (counter >= maxCount) {
            log.error("Connection timeout for antivirus component!");
            throw new Exception("Connection timeout for antivirus component!");
        }

        if (!responseFileStatus.hasBody() || Objects.isNull(responseFileStatus.getBody())) {
            log.error("Request was not processed correctly from malware scan component!");
            throw new Exception("Request was not processed correctly from antivirus component!");
        }

        log.info(Objects.requireNonNull(responseFileStatus.getBody().toString()));
        return Objects.equals(responseFileStatus.getBody().get("malicious"), false);

    }

    public static void waitForCompletion(long seconds) {
        try {
            Thread.sleep(seconds * 1000L);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }

    public boolean isNotCompleted(ResponseEntity<Map<Object, Object>> responseFileStatus) {
        return !responseFileStatus.hasBody()
                || Objects.isNull(responseFileStatus.getBody())
                || responseFileStatus.getBody().get("status").equals("InProgress")
                || Objects.isNull(responseFileStatus.getBody().get("malicious"));
    }
}
